# 디자인 패턴의 유형

이번 장에서는 디자인 패턴의 세 가지 주요 유형과 각 유형에 속하는 다양한 패턴들을 살펴보겠습니다.  
디자인 패턴은 모두 특정 객체 지향 설계의 문제나 이슈를 다룹니다.  
문제를 해결하는 방법에 있어 패턴 간에 서로 어떤 공통점을 가졌는지 찾아보고, 이를 기준으로 디자인 패턴의 유형을 분류해 보겠습니다.

### 6.1 배경
감마, 헬름, 존슨, 블리시드는 디자인 패턴을 다음과 같이 설명합니다.

    디자인 패턴은 공통 설계 구조의 핵심 요소를 이름 짓고 추상화하여 재사용할 수 있는 객체지향 설계를 만드는 데 유용한 역할을 합니다. 또한 유용한 클래스와 인스턴스를 제공하여 각각의 역할과 협업, 책임의 분배를 실현합니다.   
    모든 디자인 패턴은 특정 객체 지향 설계의 문제나 이슈에 초점을 맞춥니다. 또한 어디에 적용될 수 있는지, 다른 설계 조건에도 부합하는지, 사용함으로써 얻는 장단점과 결과를 설명합니다. 결국에는 구현이 중요하기에 구현을 위한 예시 코드도 제공합니다.  
    디자인 패턴이 객체 지향 설계를 다루기는 하지만, 결국 주요 객체 지향 프로그래밍 언어에서 구현되었던 실용적인 솔루션을 기반으로 합니다.

디자인 패턴은 어떤 문제를 해결하느냐에 따라 다음 세 가지 유형으로 분류됩니다.
- 생성 패턴
- 구조 패턴
- 행위 패턴  

각 유형에 해당하는 패턴을 살펴봅시다.

### 6.2 생성패턴
생성패턴은 주어진 상황에 적합한 객체를 생성하는 방법에 중점을 둡니다.  
기본적인 객체 생성 방식은 프로젝트의 복잡성을 증가시킬 수도 있기에, 생성 패턴은 이 과정을 **제어하여 문제를 해결하는 것을 목표로 합니다.**
생성자, 팩토리, 추상, 프로토타입, 싱글톤, 빌더 패턴이 생성 패턴에 속합니다.

### 6.3 구조 패턴
구조패턴은 객체의 구성과 각 객체 간의 관계를 인식하는 방법에 중점을 둡니다.  
그리고 시스템의 어느 한 부분이 변경되더라도 다른 부분에는 영향이 가지 않도록 도와주며, 설계 목적에 맞지 않는 부분을 개선하는 데에도 도움이 됩니다.  
데코레이터, 퍼사드, 플라이웨이트, 어댑터, 프록시 패턴이 구조 패턴에 속합니다.

### 6.4 행위 패턴
행위 패턴은 시스템 내의 객체 간 커뮤니케이션을 개선하거나 간소화하는 방법에 중점을 둡니다.   
그리고 객체 간의 공통적인 커뮤니케이션 패턴을 감지하고 책임을 분배함으로써 커뮤니케이션의 유연성을 높이고, 객체의 행위를 추상화합니다.  
이터레이터, 중재자, 관찰자, 방문자 패턴이 행위 패턴에 속합니다.

### 6.5 디자인 패턴의 분류

|생성패턴|객체 생성의 기반이 되는 개념|
|---|-----|
| | 클래스
|팩토리 매서드| 인터페이스를 기반으로 여러 파생 클래스를 생성|
||객체
|추상팩토리|구체적인 내부 구현 없이 여러 클래스가 상속받아 사용하는 인스턴스를 생성|
|빌더|객체를 생성하는 부분과 내부 구현을 분리하여 항상 같은 객체를 생성|
|프로토타입|복사 또는 복제에 사용되는 초기화된 인스턴스|
|싱글톤|전역에서 접근 가능한 하나만의 인스턴스를 가진 클래스

|구조패턴|객체구조의 기반이 되는 개념|
|---|-----|
||클래스|
|어댑터|호환되지 않는 인터페이스가 상호작용하도록 클래스를 매치
||객체|
|브릿지|객체의 인터페이스와 구현을 분리하여 독립적으로 구성|
|컴포지트|단순히 합친 상태 이상의 효율을 내는 간단하면서 복잡한 구조|
|데코레이터|객체에 새로운 프로세스를 동적으로 추가|
|퍼사드|전체 시스템의 복잡한 부분을 숨기는 단일 클래스|
|플라이웨이트|여러 객체에 공통 상태를 공유하는 세분화된 인스턴스|
|프록시|실제 객체를 대신하는 대체 객체

|행위패턴|객체 상호작용의 기반이 되는 개념|
|---|-----|
||클래스|
|인터프리터|언어의 목적과 문법에 일치하는 언어 요소를 포함시키는 방법|
|템플릿 메서드| 상위 클래스에서 기본 구조를 생성한 다음 하위 클래스에서 구체적으로 정의|
||객체|
|책임 연쇄|요청을 처리할 수 있는 객체를 찾기 위해 체인 간에 요청을 전달|
|커맨드|호출 부분과 실행 부분을 나누는 방법|
|이터레이터|내부 구조를 모른 채 요소에 순차적으로 접근|
|중재자|클래스가 서로를 직접적으로 참조하지 않도록 중간에 간소화된 커뮤니케이션을 정의|
|메멘토|나중에 복구할 수 있도록 객체의 내부 상태를 저장|
|관찰자|클래스 간의 일관성을 보장하기 위해 여러 클래스에 변경사항을 알리는 방법|
|상태|상태가 변경되면 객체의 행위도 변경|
|전략|클래스 내부에 알고리즘 구현을 캡슐화하여 상황에 따른 선택과 구현을 분리|
|방문자| 클래스를 변경하지 않고도 새로운 작업을 추가|

